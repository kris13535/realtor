{"ast":null,"code":"/*!\n * cookies\n * Copyright(c) 2014 Jed Schmidt, http://jed.is/\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n\nvar deprecate = require('depd')('cookies');\n\nvar Keygrip = require('keygrip');\n\nvar http = require('http');\n\nvar cache = {};\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n/**\n * RegExp to match Same-Site cookie attribute value.\n */\n\nvar SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;\n\nfunction Cookies(request, response, options) {\n  if (!(this instanceof Cookies)) return new Cookies(request, response, options);\n  this.secure = undefined;\n  this.request = request;\n  this.response = response;\n\n  if (options) {\n    if (Array.isArray(options)) {\n      // array of key strings\n      deprecate('\"keys\" argument; provide using options {\"keys\": [...]}');\n      this.keys = new Keygrip(options);\n    } else if (options.constructor && options.constructor.name === 'Keygrip') {\n      // any keygrip constructor to allow different versions\n      deprecate('\"keys\" argument; provide using options {\"keys\": keygrip}');\n      this.keys = options;\n    } else {\n      this.keys = Array.isArray(options.keys) ? new Keygrip(options.keys) : options.keys;\n      this.secure = options.secure;\n    }\n  }\n}\n\nCookies.prototype.get = function (name, opts) {\n  var sigName = name + \".sig\",\n      header,\n      match,\n      value,\n      remote,\n      data,\n      index,\n      signed = opts && opts.signed !== undefined ? opts.signed : !!this.keys;\n  header = this.request.headers[\"cookie\"];\n  if (!header) return;\n  match = header.match(getPattern(name));\n  if (!match) return;\n  value = match[1];\n  if (!opts || !signed) return value;\n  remote = this.get(sigName);\n  if (!remote) return;\n  data = name + \"=\" + value;\n  if (!this.keys) throw new Error('.keys required for signed cookies');\n  index = this.keys.index(data, remote);\n\n  if (index < 0) {\n    this.set(sigName, null, {\n      path: \"/\",\n      signed: false\n    });\n  } else {\n    index && this.set(sigName, this.keys.sign(data), {\n      signed: false\n    });\n    return value;\n  }\n};\n\nCookies.prototype.set = function (name, value, opts) {\n  var res = this.response,\n      req = this.request,\n      headers = res.getHeader(\"Set-Cookie\") || [],\n      secure = this.secure !== undefined ? !!this.secure : req.protocol === 'https' || req.connection.encrypted,\n      cookie = new Cookie(name, value, opts),\n      signed = opts && opts.signed !== undefined ? opts.signed : !!this.keys;\n  if (typeof headers == \"string\") headers = [headers];\n\n  if (!secure && opts && opts.secure) {\n    throw new Error('Cannot send secure cookie over unencrypted connection');\n  }\n\n  cookie.secure = opts && opts.secure !== undefined ? opts.secure : secure;\n\n  if (opts && \"secureProxy\" in opts) {\n    deprecate('\"secureProxy\" option; use \"secure\" option, provide \"secure\" to constructor if needed');\n    cookie.secure = opts.secureProxy;\n  }\n\n  pushCookie(headers, cookie);\n\n  if (opts && signed) {\n    if (!this.keys) throw new Error('.keys required for signed cookies');\n    cookie.value = this.keys.sign(cookie.toString());\n    cookie.name += \".sig\";\n    pushCookie(headers, cookie);\n  }\n\n  var setHeader = res.set ? http.OutgoingMessage.prototype.setHeader : res.setHeader;\n  setHeader.call(res, 'Set-Cookie', headers);\n  return this;\n};\n\nfunction Cookie(name, value, attrs) {\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument value is invalid');\n  }\n\n  this.name = name;\n  this.value = value || \"\";\n\n  for (var name in attrs) {\n    this[name] = attrs[name];\n  }\n\n  if (!this.value) {\n    this.expires = new Date(0);\n    this.maxAge = null;\n  }\n\n  if (this.path && !fieldContentRegExp.test(this.path)) {\n    throw new TypeError('option path is invalid');\n  }\n\n  if (this.domain && !fieldContentRegExp.test(this.domain)) {\n    throw new TypeError('option domain is invalid');\n  }\n\n  if (this.sameSite && this.sameSite !== true && !SAME_SITE_REGEXP.test(this.sameSite)) {\n    throw new TypeError('option sameSite is invalid');\n  }\n}\n\nCookie.prototype.path = \"/\";\nCookie.prototype.expires = undefined;\nCookie.prototype.domain = undefined;\nCookie.prototype.httpOnly = true;\nCookie.prototype.sameSite = false;\nCookie.prototype.secure = false;\nCookie.prototype.overwrite = false;\n\nCookie.prototype.toString = function () {\n  return this.name + \"=\" + this.value;\n};\n\nCookie.prototype.toHeader = function () {\n  var header = this.toString();\n  if (this.maxAge) this.expires = new Date(Date.now() + this.maxAge);\n  if (this.path) header += \"; path=\" + this.path;\n  if (this.expires) header += \"; expires=\" + this.expires.toUTCString();\n  if (this.domain) header += \"; domain=\" + this.domain;\n  if (this.sameSite) header += \"; samesite=\" + (this.sameSite === true ? 'strict' : this.sameSite.toLowerCase());\n  if (this.secure) header += \"; secure\";\n  if (this.httpOnly) header += \"; httponly\";\n  return header;\n}; // back-compat so maxage mirrors maxAge\n\n\nObject.defineProperty(Cookie.prototype, 'maxage', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return this.maxAge;\n  },\n  set: function (val) {\n    return this.maxAge = val;\n  }\n});\ndeprecate.property(Cookie.prototype, 'maxage', '\"maxage\"; use \"maxAge\" instead');\n\nfunction getPattern(name) {\n  if (cache[name]) return cache[name];\n  return cache[name] = new RegExp(\"(?:^|;) *\" + name.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\") + \"=([^;]*)\");\n}\n\nfunction pushCookie(headers, cookie) {\n  if (cookie.overwrite) {\n    for (var i = headers.length - 1; i >= 0; i--) {\n      if (headers[i].indexOf(cookie.name + '=') === 0) {\n        headers.splice(i, 1);\n      }\n    }\n  }\n\n  headers.push(cookie.toHeader());\n}\n\nCookies.connect = Cookies.express = function (keys) {\n  return function (req, res, next) {\n    req.cookies = res.cookies = new Cookies(req, res, {\n      keys: keys\n    });\n    next();\n  };\n};\n\nCookies.Cookie = Cookie;\nmodule.exports = Cookies;","map":null,"metadata":{},"sourceType":"script"}